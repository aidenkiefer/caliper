"""
Base strategy interface and abstract classes.

All trading strategies must implement this interface.
"""

from abc import ABC, abstractmethod
from typing import List, Optional, Dict, Any
from datetime import datetime
from decimal import Decimal

from packages.common.schemas import PriceBar, Order, Position, TradingMode


class Signal:
    """Trading signal generated by a strategy."""

    def __init__(
        self,
        symbol: str,
        side: str,  # 'BUY' or 'SELL'
        strength: float,  # 0.0 to 1.0, confidence level
        price: Optional[Decimal] = None,
        quantity: Optional[Decimal] = None,
        reason: Optional[str] = None,
    ):
        self.symbol = symbol
        self.side = side
        self.strength = strength
        self.price = price
        self.quantity = quantity
        self.reason = reason
        self.timestamp = datetime.now()

    def __repr__(self):
        return f"Signal({self.symbol}, {self.side}, strength={self.strength:.2f})"


class PortfolioState:
    """Current portfolio state for strategy decision-making."""

    def __init__(
        self,
        equity: Decimal,
        cash: Decimal,
        positions: List[Position],
        unrealized_pnl: Decimal = Decimal(0),
    ):
        self.equity = equity
        self.cash = cash
        self.positions = positions
        self.unrealized_pnl = unrealized_pnl


class Strategy(ABC):
    """
    Abstract base class for trading strategies.

    All strategies must implement this interface to be compatible
    with the backtesting and execution engines.
    """

    def __init__(self, strategy_id: str, config: Dict[str, Any]):
        """
        Initialize strategy.

        Args:
            strategy_id: Unique identifier for this strategy instance
            config: Strategy configuration dictionary
        """
        self.strategy_id = strategy_id
        self.config = config
        self.initialized = False
        self.mode: Optional[TradingMode] = None

    @abstractmethod
    def initialize(self, mode: TradingMode) -> None:
        """
        Initialize the strategy with trading mode.

        Called once before strategy starts processing data.

        Args:
            mode: Trading mode (BACKTEST, PAPER, or LIVE)
        """
        pass

    @abstractmethod
    def on_market_data(self, bar: PriceBar) -> None:
        """
        Process incoming market data.

        Called for each new price bar. Strategy can update
        internal state, but should not generate signals here.

        Args:
            bar: New price bar
        """
        pass

    @abstractmethod
    def generate_signals(self, portfolio: PortfolioState) -> List[Signal]:
        """
        Generate trading signals based on current state.

        Called periodically (e.g., after each bar or on schedule).
        Strategy should analyze current market state and portfolio
        to generate buy/sell signals.

        Args:
            portfolio: Current portfolio state

        Returns:
            List of trading signals
        """
        pass

    @abstractmethod
    def risk_check(self, signals: List[Signal], portfolio: PortfolioState) -> List[Order]:
        """
        Apply risk checks and convert signals to orders.

        This method should:
        - Filter signals based on risk parameters
        - Calculate position sizes
        - Create Order objects with proper risk limits

        Args:
            signals: Raw signals from generate_signals()
            portfolio: Current portfolio state

        Returns:
            List of approved orders (signals that passed risk checks)
        """
        pass

    def on_fill(self, fill: Order) -> None:
        """
        Handle order fill notification.

        Called when an order is filled. Strategy can update
        internal state (e.g., track entry prices, update position tracking).

        Args:
            fill: Filled order
        """
        # Default implementation does nothing
        # Strategies can override if needed
        pass

    def daily_close(self) -> None:
        """
        Called at end of trading day.

        Strategy can perform end-of-day tasks like:
        - Updating daily statistics
        - Resetting intraday state
        - Logging daily performance
        """
        # Default implementation does nothing
        # Strategies can override if needed
        pass

    def get_state(self) -> Dict[str, Any]:
        """
        Get current strategy state (for debugging/monitoring).

        Returns:
            Dictionary with strategy state information
        """
        return {
            "strategy_id": self.strategy_id,
            "initialized": self.initialized,
            "mode": str(self.mode) if self.mode else None,
        }
